#####UNIX时分系统
[原版地址](http://www.cs.berkeley.edu/~brewer/cs262/unix.pdf)
Dennis M. Ritchie
Ken Thompson
贝尔实验室
######摘要：
UNIX是一个通用的，多用户交互式操作系统，运行在DEC PDP-11/40,11/45计算机上。他提供了一些大型的操作系统从未有过的罕见特性，包括：
（1）包含了可卸载卷的层次文件系统
（2）兼容的文件，设备和内部处理I/O
（3）初始化异步进程的能力
（4）每一个用户可以定义的系统命令语言
（5）包含多种语言的100多个子系统
本文讨论的是UNIX文件系统和用户命令界面的本质和应用。

######关键词: 时分，操作系统，文件系统，命令语言，PDP-11

#####1. 介绍
UNIX现在已经有三个版本了。最早的版本（大约是 1969-1970）是运行在DEC公司的PDP-7和-9机器上。第二个版本运行在没有保护的PDP-11/20机器上。本文只描述PDP-11/40和-11/45[1]系统。相对于老版本的UNIX来说，更加现代，对一些不足和缺点也重新进行了设计。
从1971年二月以来，PDP-11 UNIX已经在40台机器上运行，提供服务了；他们一般要比这里所描述的系统小巧一些。这些系统大部分是被应用在一些实用领域，比如专利应用和其他文字材料的预备和格式化，在贝尔系统之间的切换产生的问题数据的收集和处理，还有记录和检查电话服务的订单。我们自己使用的这份系统主要是用来研究使用，一些计算机科学相关的课题，比如操作系统，语言，计算机网络，等等其他相关课题，也包括文档制作。
也许UNIX最大的贡献是表明了一个事实，那就是一个强大的交互式操作系统不需要再人力或者设备上消费大量的资源：UNIX可以运行在仅仅4万美元的硬件上，主要的系统软件也只需要2人年。现在为止，UNIX还提供了一些更复杂的大型系统所没有的特定。然而，UNIX的用户会发现系统最重要的特性是他的简单优雅，易于使用。
除了系统功能之外，在UNIX中可以使用的主要程序有:汇编器，基于QED[2]的文本编辑器，链接加载器，符号化调试器，带有类型和结构的类BCPL[3]语言编译器，BASIC方言解释器，文本格式化程序，Fortran编译器，Snobol解释器，从顶到底的编译器编译程序（TMG）[4]，从底到顶的编译器编译程序（YACC），格式化邮件生成器，宏处理器（M6）[5],还有序列化索引程序。
主机的维护程序，功能组件，重建还有有意思的程序，所有这些软件都是本地写成的。值得注意的是系统完全是自我支持的。所有的UNIX软件都是在UNIX下维护；而且所有的UNIX文档也都是由UNIX编辑器和文本格式程序生成的。

#####2. 硬件和软件环境
我们使用的PDP-11/45计算机具备16位字长（8位字节），核心内存144K；UNIX本身消耗了42K字节。系统还包含了大量的设备驱动，并且还要内I/O缓存和系统表预留大量的空间；一个最小化的系统运行上面提到的所有程序只需要50K的内存分配就可以了。
PDP-11有一个1M的固定磁头磁盘，用来做系统存储和交换分区，还有四个移动磁头磁盘驱动，每一个都可以提供2.5M的可移动卷，还有一个单独的移动磁头驱动使用可移动40M的磁盘。还配备高速的读数穿孔装置，九道磁带，还有DEC磁带（一种磁带款式，可以对磁带的单个记录进行定位和重写）。除了控制台打字机，还有14个变速通信接口，包含100系列的数据集合一个201数据集接口，主要是用在公用的输出打印机上。还有各个种类的外设设备，一个Picturephone电视电话界面，一个麦克风单元，一个声音合成器，一个照相排字机，一个数字切换网络，还有一个辅助的PDP-11/20用来在一个显示器上生成向量，曲线和字符。
UNIX软件的大部分是用C语言写的[6].早期版本的操作系统是用汇编语言写的，但是在1973年的夏天，用C语言重写了系统。新系统的大小差不多是原来的三分之一。新系统不仅是更加容易理解和修改，而且还作出了额很多功能改进，由多任务和在一些用户之间共享可重入代码的功能，他们随带来的容量开销也是可以接受的。

#####3. 文件系统
UNIX扮演的最终的一个角色就是文件系统。型用户的角度来看，共有三种文件：普通硬盘文件，目录和特殊文件。

#####3.1  普通文件
是一种包含信息的文件，无论用户在文件中放的是什么信息。比如字符程序，自己程序或者二进制程序。系统并没有定义任何特殊的结构。文件只是由字符串简单组成，行与行之间用换行符进行区分。二进制程序，是单词的序列，这些数据会在程序执行的时候加载到核心内存中。一些用户会使用更多的结构来编程操作文件：汇编器和链接器就是希望输入一种特殊的字节码格式。然而，文件的结构是由使用它们的程序来控制，不是系统来控制。

#####3.2 目录
目录提供的是文件名和文件本身的映射，因此也归纳了文件系统上的整个结构。每一个用户都有一个目录来存储自己的文件；为了更好的管理文件，在目录的下面也可以创建子目录。一个目录的行为和普通的文件别无二致，除了没有特别权限的程序无法写入之外，所以是系统控制了目录的内容。但是任何有合适的权限许可的人就可以像读取其他文件一样读取目录。
系统会保有一些自己的目录自用。其中之一就是根目录。系统中的所有文件都可以通过路径来定位，路径就是一系列目录的链条。所有检索文件的目录起始点一般就是根目录。另一个系统保有的目录是作为保存所有一般使用的程序用，也就是命令。但是并不意味着，这个目录下的程序就一定是会执行的。
文件是由14个字符，或者更少来进行命名。文件名由系统指定的时候，他的格式可能就是路径名，也就是一系列有斜线/来分割的目录，最后是文件名结尾。如果路径是由斜线/开头的话，那检索就会从跟目录开始。路径/alpha/beta/gamma会让系统从根目录开始检索alpha，之后再alpha中检索beta，最后在beta中找gamma。gamma可能是一个普通的文件，或者目录，也有可能是特殊文件。在一些情况下，斜线/本身就是指向根目录的意思。
如果路径不是以斜线开头，系统就会在当前目录开始检索。因此，名字alpha/beta就是定义了一个当前目录下的目录alpha中的文件beta。最简单的一种名字，比如alpha，就是只想当前目录下的文件alpha。在一些情况下，空的文件名就是指向当前目录的。
在多个目录下可能会存在多个一样的非目录文件。这个特性叫做链接；进入文件的目录有事由被称作链接、UNIX和其他系统不同之处在于链接一个文件的所有链接是可以有相同的状态的。也就是说，一个文件不是真实存在在伊特特定的目录里；文件的子目录仅仅是由他的名字和一个指针组成，指向的是描述文件的信息。因此一个文件的存在独立于任何子目录，虽然在实践中，一个文件会随着最后一个链接消失而消失。
每一个目录至少有两个子目录。名字点(.)，一个指向自身的目录，因此程序只需要使用点来指向当前目录，替代全路径名。名字两个点(..)是指向上层目录。
目录结构必须是树的结构。除了特殊子目录.和..，每一个目录都必须作为其他目录的子目录。这样做的原因是为了简化编程的时候访问子目录树的方式，更加重要的是避免层次结构被分裂成一部分一部分，如果允许随意链接目录树，从根目录开始的的定位检索就会很困难。
#####3.3 特殊文件
特殊文件构成了UNIX文件系统的不凡特性。每一个I/O设备在UNIX中的支持都是关联至至少一个文件的。特殊文件的读写和普通文件是一样的，但是读写的请求需要依赖于关联设备的激活状态。
每一个特殊文件的入口目录都是在目录/dev下的，但是也会偶很多目录链接到这个目录，就像普通的文件一样。因此，比个例子来说，在纸带上打一个孔洞，一种可能的方法就是是写入文件/dev/ppt。特殊文件对应于每一个通讯通道，每一个磁盘，每一个磁带驱动，还有每一个核心内存。当然，激活的磁盘和核心的特殊文件是由权限保护的。
这样处理I/O设备还有三个好处：文件和I/O设备尽可能的相似；文件和设备有着相同的名字和语法意义，所以一个程序处理文件名的方法也适用于设备名；最后，特殊文件受到和文件一样的保护机制。
#####3.4 可移除的文件系统
虽然根目录总是存储在单一的设备中，但是整个文件系统都以来一个设备是没有必要的。系统请求挂载有两个参数:现有的普通文件名和可以直接读取的特殊文件名，这个特殊文件和存储卷是关联的（比如磁盘组），独立的文件结构可以包括自己的层次目录。挂载命令的效果是将此前指向普通文件的引用指向了可移动卷上的子文件系统。从效果上看，挂载命令是将层次树上的一个子节点（普通文件），用一整个心的子树结构替代掉了（存储在可移动卷上的层次结构），在挂载命令之后，实际上在可移动卷上的文件和内部存储的文件之间是没有什么区别的。我们的系统中，举个例子，根目录是存储在一个固定磁头的硬盘中，大的磁盘驱动，会存储用户的文件，这些是系统初始化挂载的；四个小的磁盘驱动用来挂载用户自己的磁盘。一个可挂载的文件系统会通过写入他自己对应的特殊文件来生成。由功能程序来创建一个空的文件系统，或者简单靠背一个已经存在的文件系统。
在定义处理不同设备上的文件的方式的时候，只有一个规则是例外的，那就是不同设备的文件层次系统之间是不能有链接的。这个限制是强制的，是为了避免在可移除设备卸载的时候，需要确认文件链接的移除。有一个特殊的情况，无论是不是可移除，文件名 ..在根目录中都是指向自身而不是指向上层目录。

#####3.5 保护
虽然UNIX的访问控制模式是很简单的，但是还是有一些不一般的特性。系统的每一个用户都会被赋予一个独一无二的用户识别号码，UID。当一个文件被创建的时候们就会被打上一个创建所有者的标记，也就是用户ID。新建的问价也被赋予了7个保护位，其中六个是表示所有者和其他人的读，写，还有执行权限。
如果第七位是打开的，在执行文件的时候，系统就会临时改变当前用户的ID，变成文件所有者的ID。用户ID的改变只在程序执行的时候是有效的。这个设置用户ID的特性是为了那些可能使用别的用户访问不了的文件，有特别权限的程序准备的。例如，一个程序可能会拥有一个会计文件，这个文件时不可以被读取或者修改的，除非是程序自己修改它。如果设置用户ID在程序中打开了，真实的程序调用者的ID就会是可得的，设置用户ID的程序可能会验证调用者的权限程度。这个机制用来放心让用户执行那些需要特殊权限的程序。比如，系统有一个可调用的入口仅仅是为了超级用户准备的，创建一个空目录，也就是连点和点点目录都没有的目录。这个命令仅仅属于超级管理员，并且也有设置用户ID的位。之后他会检查调用者的授权，然后创建特定目录，之后再创建子目录点和点点。
既然每个用户都可能设置自己的文件的用户ID，这个机制就可以在没有管理员干涉的情况下运行。例如，保护模式就简单的解决了在[7]中的moo会计问题。
系统会分辨特定的用户ID（超级用户的ID），就可以免除一般的文件权限的检查了；因此程序可能在传输和重载文件系统的时候避免保护系统的不必要的干扰。
#####3.6 I/O调用
做输入输出的系统调用被设计成排除了设备差异和访问方式不同的样式。在随机存取和序列存取之间没有区别，任何由系统导入的逻辑节点大小也是没有区别的。普通文件的大小由写入的最高字节决定；文件大小没有预先限制就成为可能了。
为了说明UNIX I/O的基本要素，我们不适用复杂度很高的机器语言，而是使用下面的不知名语言来显示所需要的参数。每一次调用都有潜在导致一个错误的返回，调用序列的展现也不是很简洁。
假设对已经存在的文件进行存取，首先要用调用来打开文件。
`filep = open(name, flag)`
Name就是文件的名字，任意的名字都可以。Flag参数设置的问价是被读取，写入，还是更新操作，就是读写一起执行。
返回值filep是一个文件描述符。是用来标识文件的小整数，在随后的读写或者其他操作中都会有用处。
创建一个新文件或者重写一个旧的文件，需要使用系统调用create，如果文件不存在就会新建一个，存在的话就会把长度缩短到零。Create也会打开一个新的文件来写，就像open一样，会返回一个文件描述符。
在文件系统中，没有用户可见的锁存在，对用户打开的文件数量也没有任何限制。虽然在两个用户同时读写一个文件的时候会发生争抢，但实际上这种情况是很难发生的。在我们的环境中，防止用户之间对一个文件的干扰，加上锁是没有必要的。因为我们不会面对庞大的单文件数据，不会有多个进程来处理。不足的地方是，加上锁是很普通的概念，由此一个用户在其他用户读取文件的时候会被阻止去写入文件。有一些困惑还是难以避免，比如当两用户都在用编辑器编辑一个文件，编辑器会做一份文件的拷贝、
应该说系统在两个用户同时使用一个文件或者在一个目录里创建文件或者删除文件的时候，产生的冲突有足够的内部锁机制来维持逻辑上的文件系统一致性。
除了下面所说，read和write是序列化之外。也说明如果在文件中一个特定的字节是读或者写的最后一个字节，下一个I/O调用就会隐式地指向之后的第一个字节。对每一个打开文件来说是一个指针，由系统来维护的指针，来显示下一个被读取或者写入的字节。如果n个字节被读取或者写入，指针就会前进n个字节。
一旦文件打开了接下来的调用就会开始：
`n = read(filep, buffer, count)`
`n = write(filep, buffer, count)`
等到了count指定的字节数，filep指定的文件和buffer指定的缓冲就开始传输数据了。返回值n就是实际传输的字节数目。在write的情况下，n和count是一样的，除非是出了I/O错误或者到了特殊文件的物理戒指的末尾等等问题。；在read中，n在没有出错的情况下会小于count。如果read指针太接近文件的结束，count的读取范围就会超过文件末尾，传输的字节就会到文件末尾为止；还有雷打印机之类的社内不会返回超过一行的输出。当一个read调用返回的值n等于零的时候，会表示是文件的末尾。对于硬盘文件，当n等于零的时候就是读取指针等于文件的当前大小。根据设备提供的转义序列，也可以从输入生成文件结束符。
写入文件的字节只是会影响那些有写指针和count表明的位置的字节。其他字节并没有被改变。如果最后一个字节的位置超过了文件的末尾，那么文件就会根据需要扩展。
为了实现随机存取，只需要将读指针和写指针移动到合适的位置就好
`location = seek(filep, base, offset)`
关联filep的指针会被移动到一个位置，offset可能是从文件的开始，或者是从指针的当前位置，或者从文件末尾，一句base参数来。Offset可能是负值。对于一些设备（比如纸带机和打印机）seek调用是会被忽略的。从开头开始的真实的偏移量会在location中返回。
#####3.6.1 其他I/O调用
还有一些其他的系统调用，文件系统没有提及，比如关闭一个文件，取得文件的状态，改变文件所有者的保护模式，创建目录，对现存的文件创建链接，删除文件。
#####4 文件系统的实现
如3.2小节锁提及的，一个目录的入口包含的信息只有一个关联了文件的名字和一个指向文件自身的指针。这个指针式一个整数叫做i-number（就是索引数字）。当文件被访问，他的索引数就被用来作为系统表的索引使用，系统表存储在一个目录所存储的设备上。这个入口就会找到如下的信息。
1.所有者
2.保护位
3.文件内容的物理磁盘或者磁带的地址
4.大小
5.最后修改的时间
6.连接到这个文件的数目，也就是在目录中出现的次数
7.显示文件是不是目录的位
8.显示文件是不是特殊文件的位
9.显示文件是大还是小的位
系统调用open和create的目的是将用户给出的路径名转化成一个索引数，然后显式或者隐式的搜索具名目录。一旦文件被打开，他的设备，索引数，还有读写指针都会存储在系统表里面，根据open或者create返回的文件描述符来进行排序。因此在随后的文件读写调用中提供的文件描述符可能很容易关联到必要的信息来访问文件。
当一个新文件被创建，一个索引节点就会分配给他，还有包含文件名和索引数的入口也会由目录创建。创建已有文件的链接需要用新名字创建一个目录入口，从原始的文件入口拷贝一个索引数，之后给链接数字加上1。删除一个文件首先是连接数减1，之后擦除目录入口。如果连接数减到零的话，在文件中的任何磁盘区块就会被释放，索引节点也会被收回。
所有内置硬盘或者可移动存储的空间所包含的文件系统，都会被分割成512字节的逻辑区块，编号从零开始，一直到设备容量的结束。每一个文件的索引节点都有预留空间存储八个设备地址。一个小的（非特殊的）文件占据八个或者更小的区块；在这些情况下，区块的地址是自己保存的。对于大文件（非特殊文件），八个设备地址中的每一个可能指向一个由文件本身构成256个区块中的一个非直接区块。因此文件可能会是8乘以256乘以512，或者是1048576（2的20次方）字节大小。
之前提到的结论应用到普通文件上。当对一个文件提出I/O请求，文件的索引节点表示文件时特殊文件，最后的七个设备地址字是无形的，第一个被解释为一对由内部设备名组成的字节。这些字节分别定义一个设备类型和子设备数字。设备类型显示系统会按照怎样的方式来处理设备I/O；子设备数字的选择，例如，一个磁盘驱动一副一个特殊的控制器或者一些相似的打印接口之一。
在这个环境中，系统调用mount的实现（3.4小节）就很直接。挂载会维护一张系统表，参数是索引数和普通文件在挂载过程中定义的设备名，还有那些特殊设备的设备名的对应值。一个路径名在open或者create中被扫描的时候，就会为每一个索引数字和设备在表中进行搜索；如果搜索到了，索引数就会被1替代（也就是文件系统中根目录的索引号），设备名也会被表的值所替代。
对用户来说，对文件的读和写都是同步和无缓冲的。Read调用在数据取到之后就马上返回，write调用在用户的工作空间可用就马上输入。实际上是系统在维持一个非常复杂的缓冲机制，这样就可以大量减少访问文件I/O操作数量。这样就可以认为写调用是定义成字节传输的了。
UNIX会检索它的缓冲，来确认相关的银盘区块想点是不是在核心内存中；如果不是，就会从设备中读入。之后在缓冲中的相关字节就会被替代，一个新的入口也就会为了写入而创建。之后也许会从write调用中返回，但实际上I/O操作还要一些时间才能完全结束。相反的，如果是一个单字节被读入，系统就会判断在是不是第二个存储区块中定位的字节已经是系统缓存的一部分；如果是，字节就会马上返回，如果不是，区块就会读入一段缓存，字节会回收。
程序读写文件的单位是512字节比单位是单字节有优势，但是好处也不是无限的；主要是来自于避免系统维护的资源消耗。如果一个程序不是经常使用或者对于I/O的要求不是很频繁的话，读写的单位可以小一些。
索引列表的概念就是UNIX中的一个不寻常特性。在实践中，这种组织文件系统的方法被证明是可靠而且易于操作的。对系统本身来说，好处之一就是每一个文件都有一个简短，没有歧义的名字，这个名字用一个简单的方法关联到访问文件做需要的信息，保护模式，定位寻址等等。 一些简单快速的算法也会应用到检查文件系统的一致性，例如证明每一个设备的配额中包含有用的信息，被分配出去的空闲空间会解体然后一起耗尽设备的空间。这些算法是独立于目录层次的存在，仅仅需要扫描线性组织的索引列表。索引列表的概念同时还带来了其他文件系统组织方式中没有的特别特性。例如，有一个问题就是到底是谁来具体负责文件的存储，如果说所有的目录入口都有相同的状态的话。仅仅将文件装载到文件所有者是不公平的，从所有者创建文件之后，其他人也会链接到这个文件，所有者也可能会删除文件。创建文件的用户依然是所有者，但是文件应该装载给第二个用户。最简单合理的算法来均摊装载的话就是分摊给链接的所有人。当前版本的UNIX会避免这样的事情，避免所有的开销。
#####4.1 文件系统的性能
为了显示UNIX的整体效率，特别是文件系统的效率，一个7621行的汇编程序会用来显示时间。汇编语言是独自运行在机器上的；全部的运行时间是35.9秒，每秒212行代码的运行速率。时间是这样分割的：63.5%是汇编器执行时间，16.5%是系统开销，还有20%是磁盘等待时间。我们不会做出任何这些时间的解释或者对其他系统的比较，仅仅只是支出我们一般对整体的系统运行表现还是满意的。
#####5 进程和镜像
一个镜像（image）就是指一个计算机的执行环境。包含了一个核心镜像，通用注册表值，打开文件的状态，当前目录等等。一个镜像就是一个虚拟计算机的当前状态。
一个进程就是镜像的执行。 当处理器开始处理进程的细节，镜像必须加载在核心内存中l在其他进程执行的时候，镜像也还是要在核心内存中，除非是有更高权限的进程将这个镜像交换到固定磁头磁盘中。
镜像的用户核心部分被分割成三个逻辑段。程序代码段从虚拟地址空间的0字节开始。在执行期间，这段是有写保护的，而且还有一份给所有程序中运行的进程的共享拷贝。在代码段之前，虚拟地址空间中最最开始的8K字节边界是不共享的，可写的数据段，它的大小可由系统调用进行扩展。虚拟地址空间的最高地址是堆栈段，当堆栈指针移动的时候，他会自动的向下进行延展。
#####5.1 进程
除了UNIX自身的引导程序操作，一个新进程的创建只能用fork系统调用来实现。
`processed = fork(label)`
Fork由一个进程执行的时候，会分割成两个执行进程。两个进程都有独立的原始核心镜像拷贝。新的进程和父进程不一样的地方只有一点：在父进程中，控制是直接从fork返回的，在子进程中，控制需要传递给位置label。Fork调用返回的Processid就是其他进程的识别认证。
因为父进程和子进程的返回点是不一样的，所以每一个在fork调用之后存在的景象都会决定是父进程还是子进程。
#####5.2 管道
使用相同的read和write系统调用的进城之间可能会用文件系统I/O进行通信。
`filep = pipe()`
这个调用返回时一个文件描述符filep，并且创建了一个内部进程频道叫做pipe。这个频道，就像其他打开文件一样，在镜像中用fork调用从父进程传递到子进程。一个read调用会使用管道文件描述符，一直等待知道另一个进程使用相同的管道写入文件描述符。在这个点上，数据会在镜像中的连个进程之间互相传递。进程不许要有管道的概念，只要当做一个普通文件就好。
虽然通过管道进行内部进程通信是一个很有价值的工具（6.2小节），但是计算机的开始阶段，开始的进程也不是一定要设定，不算是一个据对完整的机制。
#####5.3 程序的执行
另一个主要的原始系统调用是这样子
`execute(file, arg1, arg2, …, argn)`
这个调用需要系统去读入，执行叫做file的程序，传递字符串参数arg1，arg2，…， argn。一般来说，arg1和file是相同的字符串，用来决定程序到底是调用的程序是什么名字。在进程中要使用的所有的数据和代码都会用文件中内容来替换，但是打开的文件和当前目录，还有内部进程的关系是不会改变的。只有当调用失败，比如文件没有被找到，或者执行权限位没有设置，就会有execute原始函数的数据替换；类似于使用jump机器指令而不是一个子例程调用。
#####5.4 进程同步
另一个进程控制系统调用：
` processid = wait( )`
调用者会将执行挂起，知道他的子进程执行完毕为止。之后wait会返回结束进程的processid。如果调用的进程没有派生的话，就会返回错误。子进程的具体状态也是可以获得的。Wait可能也是会展示子进程的子进程或者更加深度的派生的装套；请看5.5小节。
#####5.5 终结
最后介绍
`exit (status) `
终结一个进程，消除它的镜像，关闭打开的文件，还有擦除记录等等。当父进程通过原始函数wait报告的时候，显示父进程的状态也是可以看到的；如果父进程已经终结了，再上一层的进程状态也可以或的，等等等等。金黄曾或许会终结的时候返回一个非法的行为结果，或者是用户生成的信号（下见 第七节）。
#####6 shell
对大多数用户来说，和UNIX的交流都是在shell程序的帮助下进行的：shell程序就是一个命令行解释器：他读取用户输入的文本然后解释成请求执行相应的程序。在最简单的方式中，一个命令行是有命令名和后面的命令参数组成的，之间用空格隔开。
` command arg1 arg2 … argn`
Shell先把命令名和蚕食分成两个字符串，然后开始检索和命令名同名的程序；command可能是一个从根目录开始的路径名，指定了文件系统中的文件。如果command没有被找到，就会返回核心继续执行。Shell收集的参数对命令来说是可以访问的功能。命令完成之后，shell就会返回自己的执行状态，显示提示符等待下一个命令。
如果command命令文件没有被找到，shell就会在命令之前加上前缀字符串/bin/然后再一次尝试检索，目录/bin包含了所有的常用命令。
#####6.1 标准I/O
上面第三节关于I/O的讨论好像是说每一个程序使用的文件都必须被程序打开或创建，因为需要得到这个文件的文件描述符。程序是由shell执行的，然而一开始就有两个文件打开了，文件描述符分别是0和1。一个程序开始执行的时候，文件1就打开准备被写入，最好也可以理解成标准输出文件。除了下面展示的情况，这个文件一般都是用户列表打印机。因此一般想要写信息相关或者诊断的信息的程序一般会使用文件描述符1.相反的，文件描述符0就是用来读入的，想要读取信息的程序就会等待用户的输入，读取这个文件。
Shell可以改变这些文件描述符的标准赋值，改变打印机或者键盘的设置。如果其中一个参数是右边尖括号，“>”，文件描述符1将会在命令执行期间重定向到指定的文件。
例如ls命令，就是list，列印命令，在印表机上列印当前目录的名字。
`ls > there`
这个命令会创建一个叫做there的文件然后列印到这个文件中。因此参数“> there”的意思是输出到这个文件中。
`ed`
这个命令意思是进入编辑器
` ed < script`
这个命令的解释是将script文件作为ed命令的输入；因此“< script”的意思就是从script文件中获取输入。
虽然跟在<或者>符号之后的文件名回座位命令的参数，事实上他会被shell完全解释，不会被传递给命令。因此对于每一个命令，就不需要特殊的方法来处理I/O重定向了；命令仅仅需要使用标准的文件描述符0和1就好。
#####6.2 过滤器
标准I/O概念的扩展被用在一个命令的输出到另一个命令的输入。命令的序列被竖条所分割，shell同时执行所有的命令，安排每一个命令的标准输出从循环递给下一个命令的标准输入。因此在命令行中。
` ls | pr –2  | opr `
ls是是打印出当前目录中文件的名字了他的输出被传递给pr，pr根据日企的头部来标出页数。参数-2意思是两列。之后pr的输出会成为opr的输入。这个命令将输入缓冲进文件中，以待离线输出。
这个任务也可以更加笨拙的实现。
`ls >temp1`
`pr –2 < temp1 > temp2`
`opr < temp2`
完成之后会移除临时文件。没有I/O重定向能力的话，笨拙的方法也是可用的，首先ls命令接受用户请求进行输出，多列打印，之后输出到离线文件中，实际上令人惊奇的是，对于效率的要求是不太合情理的，像ls这样的命令的作者设置了非常非常多的输出选项。
比如pr这种程序，会拷贝标准输入到它的标准输出（带有一定处理的），这种行为叫做过滤。一些有用的过滤器执行的是字符法医，输入排序还有加密解密的工作。
#####6.3 命令分离器：多任务
另一个shell提供的功能室相对直截了当的。命令不需要在不同层次来分别，只是由分号来隔开。
`ls;ed`
第一个是列出当前目录的内容，之后进入编辑器。
一个相关的特性更加有趣，如果一个命令的结尾是&符号，shell就不会等命令结束才回到提示符，而是马上回带提示符等待接受新的命令。
`as source > output &`
Source将会被汇编，带有诊断的输出会输出到output文件中；无论汇编过程有多长时间，shell都会马上返回提示符。Shell没有等待命令的完成，进程ID会打印在输出上。这个ID可能一会命令完成或者终结的时候会有用。符号&，有可能在一行中会多次使用。
` as source >output & ls >files & `
会在后台同时执行汇编程序和列印程序。上面使用&符号的例子中，提供的是输出文件而不是打印机；如果不这么处理多个输出的话，大量的命令的输出会混合在一起。
Shell也允许括号进行命令的安排操作。
` (date; ls) >x & `
打印当前日期，之后列印当前目录，结构都输出到文件x。shell会马上返回等待下一个命令。
#####6.4 shell作为一个命令：命令文件
Shell本身就是一个命令，也可以被递归调用。假设文件tryout包含以下行。
` as source `
` mv a.out testprog`
`testprog `
Mv命令会将文件a.out重命名为testprog。A.out是汇编器的一个二进制输出，可以直接执行。因此如果上面三行被输入到控制台，source就会被汇编，结果程序被命名成testprog，之后就可以运行。这个行写在tryout文件中，输入命令
`sh < tryout`
Shell就会顺序执行命令。
Shell还有其他的功能，可以替换参数，还可以从目录中文件名的子集构造参数列表。有条件的执行命令也是可以的，条件设置成进行字符串比较，或者文件存在与否的判断，直接对区域的命令序列进行控制。
#####6.5 shell的实现
Shell操作的大致轮廓现在已经清晰了。大部分的空闲时间里，shell是在等待用户输入命令。输入行的时候以换行符作为一行的结束，shell的read调用就会返回。Shell分析这个命令行，将参数以一个合适的格式传输给execute。然后fork就会被调用。子进程，代码当然还是shell的一部分，就会尝试使用正确的参数执行execute。如果成功了，就会进入子进程，开始执行程序。与此同时，另一个由fork产生的进程，父进程正在等待子进程的完结。Shell等到一切完成之后，回到提示符，等待下一个输入。
在这个框架下，后台进程的试下你就自然而然了；无论何时一个包含&的命令行，shell都会从等待结束的阶段跳过。
值得高兴的是，所有的这个机制都和输入输出文件的概念完美融合。当一个进程被fork原始函数创建，继承的不仅仅是父进程的核心镜像还有所有当前父进程打开的文件，包括把鞋文件描述符是1和0的文件。当然shell会使用这些文件来读入输入和输出提示符，诊断信息等等，在一般情况下，shell的子进程也会自动继承的。当给出<或者>参数的时候，派生的进程在execute执行之前，会分别对文件描述符0和1进行重命名。这是很简单的，因为通过参数，一个新文件被打开或者被创建的时候，最小的没有使用的文件描述符就会被赋值进去。；只是关闭文件描述符0或者1，之后打开具名文件。因为命令程序运行完成的那个进程的结束，文件描述符也会自动结束生命周期。因此shell不需要知道文件的真实名字，因为不需要在重新打开了。
过滤器就是用管道而不是文件进行标准I/O重定向的直接扩展。
在一般环境下，shell的主循环永远不会终结。（主循环包括从fork属于父进程的返回的分支；就是那个进行wait，读取下一个命令的分支）。引起shell终结的事情有意见就是发现到了输入文件的末尾。因此当shell作为一个命令来执行，并给出一个文件
`sh < comfile`
在comfile文件中的命令将会被执行，一直到文件的末尾；由shell分支出来的shell实例就会终结。既然shell进程是另一个shell的子进程，wait执行完毕后，其他命令还是可以执行的。
#####6.6 初始化
用户用来输入命令的shell实例，本身也是其他进程的子进程。UNIX初始化的最后一本就是创建一个单独的进程和一个叫做init的程序请求（通过execute）。Init为每一个打印机通道创建一个进程，这些输出设备可能会被用户所请求。大量init的子实例打开对应的打印机来输入输出。当init被调用的时候，并没有被打开的文件，在每一个进程中，打印机和键盘都会接受文件描述符0的输入和1的输出。每一个进程输出一个请求信息来让用户登录，之后等待输入。在一开始的地方，没有用户登录，进程就简单挂起。终于有一个用户键入了名字或或者其他ID。Init对应的实例就会被唤醒，接受登录行，读取口令文件，init切换到用户的默认当前目录，设置已经登录的用户的ID给进程，之后执行shell实例。这时候shell已经准备好接受命令了，登录协议也已经完成。
与此同时，init的主要路径（他自身的所有实例的父路径，之后会成为shell）进入wait。如果有一个子进程终结了，或者因为shell到了文件的地步或者用户输入了不正确的用户名和口令，init的路径就会简单重构僵尸进程，重新打开对应的输入输出，输出登录提示信息。因此一个用户登出shell的方式也可以不输入命令，而是键入文件休止符。
#####6.7 其他作为shell的程序
上面描述的shell的设计，是可以允许用户完全访问系统功能的，用户可以再保护模式下调用任何程序执行。有时候，一个不同的系统接口是很好的，这个特性也很容易实现。
在用户成功登陆之后回调，init调用shell来解释命令行。在空密码文件中用户的入口可能包含一个程序的名字来在登陆之后替换shell实例。这个程序是可以自由解释成用户希望的任何信息的。
例如，口令文件对用户的入口的加密编辑系统定义，编辑器ed用来替换shell。当用户登录的时候，内部的编辑器就会马上启动；也可以用来防止用户对UNIX程序进行误调用。在实践中，允许从编辑器中临时离开去执行格式化程序或者其他功能程序是一个很好地设计。
有一些游戏（比如棋，21点，3D三连棋）在更加高级的UNIX系统上也是可以玩的。每一个口令文件中存在的入口都定义了对应的游戏程序来取代shell。人们登录的时候是作为一个玩家。
#####7 中断
PDP-11硬件检测出一些程序错误，比如对于不存在的内存地址引用，未实现指令，还有偶地址请求的奇地址使用。这些错误因此了处理器陷入了一个系统例程。当一个非法操作被捕捉，除非有其他安排，系统会终结进程，写入用户镜像到当前目录的文件core。出错的时候可以使用调试器来判断程序的状态。
在循环中的程序，产生了不想要的输出，或者用户有了别的想法，可以使用interrupt信号来进行中断。除非是特别的操作，不然这个信号会让程序停止，并且不会生成核心镜像文件。
也有一个qiut信号是用来中断的，而且会生成核心镜像文件。不正确循环的程序会被停止，核心镜像进行没有预先安排的检查。
硬件生成错误，中断信号还有quit信号都可以忽略或者由进程来捕获。例如，shell会忽略由用户登出而出现的quit信号。编辑器捕获中断，返回给命令层。在暂停很长的输出但是不中断这一过程，是非常有用的（编辑器操作文件正在编辑的备份）。在没有浮点数处理的硬件系统中，会捕获未实现指令，浮点数指令会被中断。
#####8 远景
可能是有点荒谬，UNIX的成功很大程度上是应为它的设计并不是按照任何既定的目标来的。第一个版本由我们之一写成（Thompson）的时候，对于能用的计算资源很不满意，之后发现一台很少人用的PDP-7系统，紧接着就开始开发一个更加友好的系统环境。这种个人兴趣很能获得成就感和引起其他人兴趣。之后在申购PDP-11/20的时候，特地要求支持了文字编辑和格式化系统。自后11/20依次发展，UNIX被证明是足够有用的，说服了管理层投资了PDP-11/45。我们的目标总数专注于建立一个舒适的人际环境，能方便的在操作系统上浏览好的点子和发明。我们没有必要去满足他人的要求，只是纯粹喜欢做这些事情。
会想UNIX的设计，有三点是很有影响的。
首先，既然我们是程序员，自然地，系统的设计对程序的编写测试，运行都是非常友好的。我们最渴望对变成方便的表达式系统是交互式使用的，甚至是在原始版本只支持一个用户的时候也是的。我们相信一个设计合理的交互式系统会更加有生产力，比一个批处理系统更加让人满意。这样一个系统其实非交互式使用也是很方便的。
第二点，在系统和软件上，总是有一些大小限制存在。在效率和表现力之间艰难的抉择，大小限制不仅仅是有经济原因，还有就是设计的优雅问题。这也许就是一个哲学问题，苦难得救赎的简化版本，但是我们最终还是做到了。
第三，从一开始，系统就是可以也是这么做的，维护自身。事实总是比看起来要重要。如果系统设计者被强迫使用那个系统，他们很快就会意识到那些功能上肤浅的缺陷，斌企鹅会有很强的动力在为时过晚之前去修正它。既然所有的源代码程序都是可以在线获得和修改，我们就很方便的修改系统，在别人建议或者想到好主意的时候马上修改。
本文中讨论的UNIX的一些方面清楚展示了设计考量的前两点。文件系统的接口，例如，从编程角度来说极端方便。最底层的接口被设计成忽略了不同设备和文件之间的差异并且可以进行直接的序列化的存取。不需要大型的访问方法例程来把程序员和系统调用隔离开来。事实上，所有的用户编程都可以直接进行系统调用或者使用一个小型的库程序，只有十行指令长度，一次性缓冲字符和一次性读写。
编程方便的另一个重要方面是没有复杂结构的控制区块，不会依靠文件系统或者其他系统调用来维护控制区块。一般来说，程序地址空间的内容就是程序的属性，我们已经尝试避免用地址空间开限制数据结构。
有一个需求是这样，所有的程序对于任何文件或者设备都应该是输入输出可用的，从空间效率的观点上看将设备依赖的考虑丢给操作系统也是很必要的。
#####8.1 影响
UNIX的成功并不是基于什么新的发明，而是对亦有的一些红的想法进行了取舍，特别是在可以成为操作系统的关键部分的一些做法。
Fork操作，基本上使我们实现的，出现在Berkley 时分系统中。在一些地方我们受到multics的影响，一些I/O格式的特殊调用还有shell的名字和一些通用函数。Shell对命令创建进程的方式也是从multics来的，虽然这个操作系统因为效率原因放弃了。但是相似的模式被tenex所使用了。
#####9 统计
下面的统计是用来展示UNIX的系统规模以及这样规模的系统如何被使用的。我们那些没有文档工作需要的用户倾向于软件开发，特别是语言工作。还有一些重要的应用程序。
#####9.1 总计
72 用户
14 最大同时在线用户
300 目录
4400 文件
34000 512自己玩二级存储区块被使用
#####9.2 每天（一天二十四小时，每周七天）
后台程序在最低权限下运行；用来填满任何空闲的CPU时间。生成常量e的-2次方的百万位近似值，现在正在生成混合伪质数（基数2）。
`1800 commands`
`4.3 CPU hours (aside from background)`
`70 connect hours`
`30 different users`
`75 logins`
#####9.3 命令的CPU使用（1%分割）
使用率|命令
---|---
15.7% |C compiler 
15.2% |users’ programs 
11.7% |editor 
5.8% |Shell (used as a command, including command times)
5.3% |chess 
3.3% |list directory
3.1% |document formatter 
1.6% |backup dumper 
1.8% |assembler
1.7% |Fortran compiler
1.6% |remove file
1.6% |tape archive
1.6% |file system consistency check
1.4% |library maintainer
1.3% |concatenate/print files
1.3% |paginate and print file
1.1% |print disk usage
1.0% |copy file

#####9.4 命令访问
使用率|命令
---|---
15.3% |editor
9.6% |list directory 
6.3% |remove file 
6.3% |C compiler
6.0% |concatenate/print file 
6.0% |users’ programs 
3.3% |list people logged on system 
3.2% |rename/move file 
3.1% |file status 
1.8% |library maintainer check
1.8% |document formatter 
1.6% |execute another command conditionally
1.6% |debugger
1.6% |Shell (used as a command)
1.5% |print disk availability
1.4% |list processes executing
1.4% |assembler
1.4% |print arguments
1.2% |copy file
1.1% |paginate and print file
1.1% |print current date/time
1.1% |file system consistency
1.0% |tape archive

#####9.5 可靠性
我们对可靠性的统计比其他的更加主管。记下来的结果是收集的数据中最好一部分。时间分片是一个早期的11/45的版本的一年时间。
崩溃是指非计划的当机或者重启，几乎是每一天都有；大约三分之二是硬件相关引起的，比如掉电和莫名其妙的处理器中断。剩下的醉成没有中断时间是两周。服务调用平均每三周一次，但是确实集群负载。总的时间是24小时是98%。
#####致谢
非常感谢R.H. Canaday,L.L. Cherry, 和L.E. McMahon 他们对UNIX的贡献。我们特别感谢R.Morris,M.D. McIlroy, and J.F. Ossanna.的创造性，合理的批判和长期的支持。
#####参考书目
1. Digital Equipment Corporation. PDP-11/40 Processor Handbook, 1972, and PDP-11/45 Processor Handbook. 1971.
2. Deutsch, L.P., and Lampson, B.W. An online editor. Comm. ACM 10, 12 (Dec, 1967) 793–799, 803.
3. Richards, M. BCPL: A tool for compiler writing and system programming. Proc. AFIPS 1969 SJCC, Vol. 34, AFIPS Press, Montvale, N.J., pp. 557–566.
4. McClure, R.M. TMG—A syntax directed compiler. Proc. ACM 20th Nat. Conf., ACM, 1965, New York, pp. 262–274.
5. Hall. A.D. The M6 macroprocessor. Computing Science Tech. Rep. #2, Bell Telephone Laboratories, 1969.
6. Ritchie, D.M. C reference manual. Unpublished memorandum, Bell Telephone Laboratories, 1973.
7. Aleph-null. Computer Recreations. Software Practice and Experience 1, 2 (Apr.–June 1971), 201–204.
8. Deutsch, L.P., and Lampson, B.W. SDS 930 time-sharing system preliminary reference manual. Doc. 30.10.10, Project GENIE, U of California at Berkeley, Apr. 1965.
9. Feiertag. R.J., and Organick, E.I. The Multics input-output system. Proc. Third Symp. on Oper. Syst. Princ., Oct. 18–20, 1971, ACM, New York, pp. 35–41.
10. Bobrow, D.C., Burchfiel, J.D., Murphy, D.L., and Tomlinson, R.S. TENEX, a paged time sharing system for the PDP-10. Comm. ACM 15, 3 (Mar. 1972) 135–143.
------------------------------------------------------------------
KNR在1974年的论文，在我出生之前好多年，有一种恍如隔世的感觉。那时候UNIX还是实验室里的玩物，看看论文里列出来的硬件配置，现在看看好可怜，DEC可能就是当年的计算机制造商里好的吧，16位计算机，144K内存，40M硬盘，输出是印表机，我想他们做系统的时候应该是都穿着白大褂，坐在计算机的房间里，真的是庞然大物啊！
但是就是那时候的一个小创造，论文里说，UNIX的实现的原因仅仅是个人目的，是为了玩儿游戏，没有其他的计划，也没有任何高大上的目的。UNIX也不是凭空创想出来的，是接了很多当时已经有的想法，东拼西凑，精挑细选来实现的，后来才慢慢走上了王道。
想起一直的一个论调，到底是Unix用的多还是windows用的多呢？一般的感受肯定是windows，想想pc的时代，几乎所有的个人，企业都离不开微软，离不开windows，office。但是真正无处不在的是Unix，当然是Unix和类Unix，后面的发展真的是太激动人心，后来的Linux，Mac，甚至是iPhone，android就更不必说了，大型机，服务器，超级计算机，真正无处不在的是Unix。
最让我感动的一点是什么？那就是时间，这篇论文是1974年发表的，其中的知识到现在还不过时，文件，目录，访问权限，设备和文件一视同仁，存取机制等等，这就是所谓的经典不死吧。有人说，存在了越久的东西继续存在下去的可能性就越大，Unix的40年，我想他还会继续辉煌40年也不成问题。
一个辉煌的产业，或者说一个新的时代，可能一开始都是源自于一个人或者一群人做的毫无关系的事情而引发的一系列后果。图灵发明的计算机目的是为了破译德军的密码，KNR写Unix是因为项目空闲的时候想玩一个游戏，今天的世界都在讲互联网的时代在革旧传统命，一个崭新的时代帷幕眼看拉开了。这样的世界来自于很久很久之前，有那么几个人，一群人，他们来自于不同的时代，身份地位各不相同，做的事情，做的目的也千差万别，但是在很久很久之后，一个伟大的时代正是由于他们当年的一些为了高兴小举动，无心的拨动了时间的指针，就成就了一个时代。
敬那些不知道自己在做什么，只是为了高兴，但是却有划时代意义的人。
