#####7.1 编译UNIX软件包
有很多自由软件或者是商业软件包被安装在我们的系统上，对于所有的用户都是可用的。但是每一个用户也可以安装自己想要的软件，只是对个人来说是有用的。
安装一个软件需要如下几个步骤：
1. 下载源代码（一般是一个压缩文件）
2. 解压缩源代码
3. 编译源代码
4. 安装可执行文件
5. 设置安装目录的环境变量

以上的步骤中，最难的也许就是编译阶段了

######编译源代码
所有的高级语言代码都必须转换成一个计算机可以理解的形式。比如C语言的源代码就会转换成一个底层的语言，汇编语言。汇编语言代码阶段之后就是字节码，这样的代码序列计算机就可以直接理解了。最后的阶段是将程序编译的代码和系统的内建库进行链接，生成可执行程序。
所有的这些步骤都是极端复杂，已经超越了一般用户力所能及的范围。为了简化这些步骤，一些好用的组件和工具有程序员开发出来供终端用户使用，以简化这些步骤。

######make和Makefile
命令make可以让程序员来管理大型的程序或者程序的组织结构。当程序中的一部分被修改，不必编译项目的所有部分，只要编译修改过的部分就可以了。
make命令组织变异的方式来自于一个叫做Makefile的文本文件，这个Makefile文件盒源代码是放在一个目录下的。包含的信息就是说明如何编译软件，例如在优化阶段，决定是不是在最终程序中包含调试信息之类的问题。这个文件也会包含一些最终的文件安装到何处的信息等等，还有手册页，数据文件，所需要的库文件和配置文件等等。
一些包需要你手动编辑Makefile文件来设置最终的安装目录还有其他的参数。然而，很多包现在已经随GNU配置组件一起分发了。

######配置
随着UNIX变种的增加，写一个可以运行在全部系统版本上的软件变得很难了。开发者常常是没有权限进入每一个系统，系统不同版本的字符集也是各不相同。GNU的配置系统简化了程序分发成源代码的构建构成。所有程序的构建都是用简单标准的两个过程。程序的构建者不需要安装特殊的工具来构建程序。
configure shell脚本会尝试去猜测不同的系统在编译的时候使用的变量的正确之。使用这些值来为每一个包构建一个Makefile。
编译一个包最简单的方法就是：

1. 切换到包含包源代码的目录
2. 输入./configure来对你的系统和包进行配置
3. 输入make来编译包
4. 可选的，输入make来运行包自带的自我测试
5. 输入make install来安装程序文件和数据文件，还有文档手册
6. 可选的，输入make clean来删除所有二进制文件和字节码文件

configure组件支持非常非常多的额选项，可以使用--help来查看需要的选项意思和特使的配置脚本
有一个选项会使用比较频繁，--prefix和--exec-prefix，这两个选项用来指定安装的目录。
跟在--prefix后面的目录是安装一些与机器无关的文件，比如文档，数据还有配置文件。
选项--exec-prefix后面的是可执行文件的目录，一般是prefix的目录的子目录。

#####7.2 下载源代码
[猛击这里下载源代码](http://www.ee.surrey.ac.uk/Teaching/Unix/units-1.74.tar.gz)
下载之后放到一个单独的目录中。

######7.3 解压缩源代码
下载下来的文件名字是以.tar.gz结尾的。tar命令是将一些文件打包成一个文件使用的命令。之后

再使用gzip压缩，生成一个tar.gz文件。
首先使用gunzip命令解压缩，创建一个.tar文件
`% gunzip units-1.74.tar.gz`
之后再解压缩tar文件
`% tar -xvf units-1.74.tar`

#####7.4 配置和创建Makefile
要做的第一件事情就是仔细的阅读文本文件README和INSTALL。这两个文件包括了编译和安装软件的

重要信息。
包units使用GNU configure系统来编译源代码。我们需要指定安装的目录，默认的目录就是你具有

权限的主要目录。可以自己创建一个目录来进行安装。
`% mkdir ~/units174`
之后运行configure组件来指定安装路径
`% ./configure --prefix=$HOME/units174`
注意：
变量$HOME是一个环境变量的例子，他的值是你的主目录的路径
`% echo $HOME`
就会返回你的主目录路径

如果configure运行正确，就会创建Makefile文件，你可以看看这个文件，但是不要去修改他的内

容。
#####7.5 构建包
现在就可以通过make命令来构建包了
`% make`
一两分钟后（根据计算机性能），可执行文件就会被创建。你可以用check来检查一下
`% make check`
如果都OK的话，现在就可以安装包了
`% make install`
会安装在之前创建的 ~/units174 目录中

#####7.6 运行软件
现在你就可以看见软件安装好了（如果都OK的话）
切换到安装目录，就可以看见下面几个目录
名字|内容
---|---
bin|二进制文件
info|GNU info格式的文档
man|手册页
share|共享数据文件

向运行程序，必须是在bin目录下
`% ./units`
举个例子，将6英尺转换为米
`You have: 6 feet`
`You want: metres`
`* 1.8288`

OK，如果得到的结果是1.8288，那么恭喜你，没问题了。
如果想要知道units程序可以转换的所有单位，请查看目录share中的数据文件（很容易理解）。
想要阅读所有的文档，可以切换到info目录，然后输入
`% info --file=units.info`

#####7.7 去除不必要的代码
在开发软件的时候，在执行文件的结果中包含调试信息是很有用的。这样的话，如果问题出现就可以利用调试器来追踪定位问题。
虽然这些个信息对开发者很有用，但是随用户来说是没有必要的。我们可以假定软件包一旦完成，可以获得下载版本肯定是已经测试和调试过的。然而，当我们编译上面的软件时，调试信息依然编译进了最终的可执行程序。既然我们不需要这个调试信息，就从最终文件中去除他吧。这样做的好处之一就是结果文件的大小会精简，运行也会快一些。
我们要做的就是观察二进制文件在之前和之后的大小的对比，可以使用file命令来看看文件的信息。
`% file units`
`units: ELF 32-bit LSB executable, Intel 80386, version 1, dynamically linked (uses shared libs), not stripped`
之后使用strip命令来去除所有的调试信息和行号信息。
`% strip units`
`ls -l`
首先是文件的大小，成为了原来的三分之一，原来二进制文件的三分之二都是调试信息。
之后检查一下文件信息
`% file units`
`units: ELF 32-bit LSB executable, Intel 80386, version 1, dynamically linked (uses shared libs), stripped`
有时候你可以使用命令make来安装已经去除了信息的版本，只要把make install 换成make 

install-strip。
