####10 对象初始化
到目前为止，我们已经使用了两种不同的方法来创建对象。第一种是[类名 new]，第二种是[[类名 alloc] init]。这两种方法是等

价的，不过Coca管理是使用alloc和init而不是用new。一般情况下，Cocoa程序员在熟练使用alloc和init方法前将new作为辅助方法

使用。现在是时候把它丢掉了。
#####10.1 分配对象
分配（allocation）是一个新对象诞生的过程。最美好的一刻，就是从操作系统获得一块内存，并将其指定为存放对象的实例变量

的位置。向某个类发送alloc消息，就能为类分配一块足够大的内存，以存放该类的全部实例变量。同时alloc方法还顺便将这块内

存区域全部初始化为0.这样你就不必担心由于未初始化内存而引起的各种随机Bug（这在许多语言中都曾出现过）。所有的BOOL类型

变量被初始化为NO，所有的int类型变量被初始化为0，所有的float类型变量被初始化为0.0，所有的指针被初始化为nil。
刚刚分配的独享并不能立即使用，你需要先初始化，然后才能使用。有些语言（包括C++和Java），使用构造函数在一次操作中便执

行完对象的分配和初始化。OC将这两种操作拆分成为两个明确的步骤：分配和初始化。初学者常犯的一个错误就是只执行分配操作

而未进行初始化：
Car *car = [Car alloc];
这样的代码也能运行，但是由于没有进行初始化，可能会出现奇怪的行为（也就是bug）。本章剩余的篇幅将全部用于讲解出事这一

个核心概念。
#####10.1.1 初始化对象
与分配对应的操作时初始化。初始化从操作系统取得一块内存用于存储对象。init方法（即执行初始化操作的方法）一般都会返回

其正在初始化的对象。你应该像下面这样嵌套调用alloc和init方法：
Car *car = [[Car alloc] init];
而不是这样
Car *car = [Car alloc];[car init];
这种嵌套调用技术非常重要，因为初始化方法返回的对象可能与分配的对象不同。虽然这种情况很奇怪，但是它的确会发生。
为什么程序员会允许init方法返回不通过的对象呢？如果您还记得第8章末尾关于类簇的讨论，那么就会明白，像NSString和

NSArray这样的类实际上只是一些特殊类的虚假表象。由于init方法可以接收参数，因此它的代码能够检查其接受的参数，并决定返

回另一个类的对象可能更适合。例如，我们假设一条字符串可能是由一段很长的文本组成的，也可能是由遗传阿拉伯数字组成的。

基于这些情况，字符串初始化函数可能会决定创建一个不同类的对象（该对象更符合目标字符串的要求），然后返回该对象而不是

原来的对象。
#####10.1.2 编写初始化方法
前面在展示初始化方法的用法时，曾要求你暂且不去细究，主要是因为这些方法看起来是有点奇怪的。如下所示是一个早期版本的

CarParts类的init方法。
(id) init
{
if (self = [super init]){
engine = [Engine new];
tires[0] = [Tire new];
tires[1] = [Tire new];
tires[2] = [Tire new];
tires[3] = [Tire new];
}
return (self);
}// init
最让人感到奇怪的是这一行
if (self = [super init]){
这行代码意味着self可能发生了改变。在方法中更改self？你疯了吧？也许吧，不过这次没疯。该声明中最先运行的代码是[super 

init]，其作用是让超类完成其自身的初始化工作。对于继承了NSObject的类来说，调用超类的init方法可以让NSObject执行它所需

要的所有操作，以便对象能够响应消息并处理保留计数器。而对于从其他类继承的类，通过这种方法可以实现自身的全新初始化。
刚才已经提到过，像这样的init方法可能会返回完全不同的对象。请记住，self参数是通过固定的距离寻找实例变量所在的内存位

置的。如果从init方法返回一个新的对象，则需要更新self，以便气候的实例变量的引用可以被映射到正确的北村位置。这也是需

要使用self = [super init];这种形式进行赋值的原因。还要记住这个复制操作只影响该init方法中的self的值，而不影响该方法

范围外的任何内容。
如果在初始化一个对象时出现问题，则init方法可能会返回nil。比如使用init方法接受一个URL，并使用网站的图像文件初始化一

个图像对象。如果网络出现故障，或者重新设计的网站删除了这幅图像，你就无法获得一个幼小的图像对象。init方法将返回nil，

标明未能初始化该对象。如果从[super init]返回的值时nil，则if (self = [super init])的判断不会让主体代码执行。像这样将

赋值和检查是否为控制结合起来是一种典型的C语言风格，OC沿袭了这一风格。
获得对象并使其运行的代码位于if语句正文部分的一对花括号里面。在最初的Car类的init方法中，if语句创建了一个engine对象和

4个tire对象。从内存管理的角度来看，这段代码是完全正确的，因为通过new方法返回的对象在开始运行时保留计数器的值被设置

为1.
该init方法的最后一行代码是“return（self）；”。
init方法反悔了刚刚已经被初始化的对象。我们已经将[super init]的返回值赋给了self，这正是应该返回的值。
#####初始化的正确方法
有些程序猿不喜欢将赋值和判断是否为空结合起来，而是使用如下方式编写自己的init方法
self = [super init];
if (nil != self){
...
}
return(self);
这样也很好。关键是你要讲返回值赋给self，尤其是即将访问某个实例变量时。无论使用哪种方式来实现init方法，一定要明白，

将赋值和条件判断结合起来是一种常见的计数，你将会在其他人的代码中经常见到这种情况。
self = [super init]这种形式是引起一些争议的根源，一部分人认为，初始化过程中超类可能改变一些对象，所以以防万一应该使

用这种形式。另一部分人认为，这种对象改变的情况非常少见而且难以理解，因此不用理会，只是用简单明了的[super init]形式

就可以了。持有这种观点的人指出，即使init改变了对象，新对象也可能无法使用已经添加的新实例变量。
在理论上一个十分棘手的问题，但实际上这种情况很少发生。我们建议一直使用if(self = [super init])这种技术，以确保安全并

能捕获某些init方法返回nil的行为。当然，如果使用简单明了的[super init]也可以，只不过遇到难以理解的个别情况，你可能需

要进行一些调试。
#####10.1.3 初始化时要做些什么
你应该在init方法中进行哪些工作？在这里，你要执行全新的初始化工作，给实例变量赋值并创建你的对象进行工作时所需的其他对象。在编写自己的init方法时，你必须确定在该方法中希望完成多少工作。在CarParts程序不断演化的过程中出现了两种不同的初始化方式。
第一种方式使用init方法创建了engine对象和全部的4个tire对象。这种方式使得Car类变得出产即用（调用玩alloc和init方法就可以用来工作了。）而在另一种方式中，我们在init方法中不创建任何对象，只为engine对象和tire对象预留位置。创建了Car对象的方法还必须负责创建其中的engine对象和tire对象，并通过访问方法为其赋值。
哪种方式更适合你?这取决于灵活性和性能的平衡，在程序设计中经常要做这种取舍。前一种方式中原是的init方法非常简便。如果Car类的用途是创建和使用默认的Car对象，则第一种方式更为合适。
另一方面，如果car对象要定制不同种类的引擎和轮胎（比如在赛车游戏中），我们创建的这些默认engine对象和tire对象只能丢掉。这样太浪费资源了，创建的对象从未使用就被销毁了。
说明 即便你目前没有设置自定义属性的值，也英爱等到调用者需要时再创建对象。这种技术被称为惰性求值（lazy evaluation）。如果你要自己的init方法中创建复杂大师世纪可能用不上的对象，则使用这种技术可以提高程序的性能。

