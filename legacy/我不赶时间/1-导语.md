####1 导语
Common Lisp是一门新的Lisp方言，继承自MacLisp，受ZetaLisp的影响，某种程度上也受Scheme和Interlisp影响。
#####1.1 目标
Common Lisp想要达到这些目标：
*通用*
Common Lisp源自于一种整合已有实现的尝试，这些不同的实现都是源自于MacLisp，只是实现的环境有着差别，所以开始逐渐分化。微型个人电脑（ZetaLisp，Spice Lisp），商用时分计算机（NIL-“New Implementation of Lisp”），还设有超级计算机（S-1 Lisp）。一些实现环境的差别慢慢地导致了Lisp实现本身的不兼容，Common Lisp就是作为一种通用的方言，每一个实现都可以创建任何扩展。
*可移植*
Common Lisp有意摒弃了那些一般机器实现起来不易的特性。也就是那些实现起来很困难或者很昂贵，没有特殊编码的硬件就难以实现的特性，这样的特性会被摒弃或者以一种更加抽象且高效的可实现方式来提供。（比如ZetaLisp中的部件前导指针和位置。一些由他们解决的问题会在Common Lisp中以另一种方式解决）。那些只在指定的普通或者商业处理器上有用的特性会被摒弃或者设置为可选。（类型声明就是这类例子，一些实现中是很有用，一些实现直接无视，类型声明会是完全可选的，对于科室的程序会是很有效的，而不是语法强制的实现）。Common Lisp是容易写程序的语言，尽量不对特定的机器细节进行定义，比如字长，会允许实现进行一些变化。
*一致*
大部分Lisp实现在内部是不一致的，在处理程序的时候，编译器和解释器的语法是不一致的。这个语法区别首先起源于这样一个事实，解释器假设所有变量都是动态的作用域，但是编译器是假设所有变量都是局部变量，除非直接显式地声明他。这个区别是带来了便利可高效，但是也会导致很恼人的BUG。Common Lisp的定义避免了这样的异常，要求解释器和编译器引入完全一样的语法。
*表现*
从InterLisp，MacLisp，其他Lisp方言，甚至其他编程语言中，Common Lisp挑选出一些久经考验的最有用，最容易理解的结构。被证明是糟糕的结构或者没什么用的就会被摒弃。（一个例子就是MacLisp中的store结构）。
*兼容*
除非是不得已才有所冲突，不然Common Lisp会努力和Lisp Machine Lisp，MacLisp，还有InterLisp保持兼容，基本上就是这个顺序。
*性能*
Common Lisp为帮助生成高质量的编译代码而设计了一些特性，这样非常关注性能的开发者就可以在他们的实现中使用了。Common Lisp的实现之一，S-1 Lisp，它的编译器生成的代码在数字计算的执行速度上和Fortran编译器相比也是很有竞争力的。S-1 Lisp编译器将工作延伸到MacLisp来生成极端高效的数字代码。
*强大*
Common Lisp是一个MacLisp的派生版本，MacLisp传统上就注重提供系统构建级别的工具。这些工具会被用在构建用户级别的包别如InterLisp所提供的那些；然而这些包不是Common Lisp定义的核心部分。这些包会被构建在Common Lisp核心的顶层。
*稳定*
Common Lisp的变化会缓慢而且深思熟虑。非常非常多的方言在实验室里面作为语言的扩展来测试，他们是Common Lisp的超集，要经过十分小心的测试和实验，最终才会被假如Common Lisp本身的定义中。
Common Lisp的目标与Standard Lisp还有Portable Standard Lisp很接近。Common Lisp和Standard Lisp的主要区别在于更多的特性，包括更加丰富复杂的数据类型，更加复杂的控制结构。
这本书倾向于是一本语言定义，而不是一本实现定义（虽然实现的注解散布在整个文本中）。本书定义一个标准语言概念的集合，还有会在数据结构通信和算法中用到的结构。概念和结构的集合有时候也被称作Common Lisp语言核心，因为它包含了必须的概念和重要的特性。本书不是实现必须项目的最小子集。当很多特性可以以Lisp代码来实现的时候，事实上也的确会这么实现，感觉上来说，这些特性应该是原始的以至于所有的用于也是这么使用的。（例如，大数字和番薯可能是由Lisp代码来实现的，是定点数实现的。然而，重要的是这个语言概念上的整数是被用户当做原始的，也值得被当做是标准的一部分）。
大部分来说的话，这本书定义的是一种编程语言，而不是一个编程环境。定义的是一些接口，在系统中当做标准编程工具调用，编译器，编辑器，程序追踪，调试器，但是具体的细节本质和操作我们不追究。使用的Common Lisp作为基础的扩展编程环境会在其他的文档里面描述。
现在有很多Common Lisp实现，是大学里的研究小组实现的版本或者公司商业售卖的版本，一定数量的编程环境却是依托这些实现成长起来了。上述所有的目标都已经实现了，尤其是可移植方面。将大规模的Lisp代码从一台计算机迁移到另一台已经不是很艰难了。
#####1.2 表示惯例
为了简洁，贯穿全书我们都使用特殊的表示惯例。
######1.2.1 十进制数字
本书中的所有数字都是十进制数字，除了一些特殊的显式标记之外。（十进制标记当然是最容易接受的，对于特定的Lisp方言，MacLisp特别是，默认的数字表示是8进制而不是十进制，所以引入十进制来表示Common Lisp，实际上算是一种颠覆）
######1.2.2 NIL，False和空列表
在Common Lisp中，在大部分Lisp方言中，符号nil被用来表示空列表，还表示布尔测试里false的值。当然一个空列表也可以这么写()；正常情况下，()的同一个对象的指的是nil。（在包系统的操作极端异常的情况下，nil指向的不是空列表而是有其他同名的值的可能也是有的。我们会忽视这种混淆出现的可能性）。()和nil可以互换，只要是在Lisp系统中的话。但是为了风格着想，我们会使用()来表示空列表的情况，用nil来表示布尔值是false的情况。'nil标记（请注意那个明显的单引号记号），用于强调这是在使用一个符号。例如：
``(defun three () 3);强调这是一个空列表``
``(append '() '());强调空列表的使用``
``(not nil)->t;强调的是布尔值false的使用``
``(get 'nil 'color);强调的是作为符号的使用``
除了nil之外的所有数据对象都被解释成布尔值非false，也就是true。没有其他的值更加合适的时候，符号t惯例上被用来表示true。在一些情况下，一个函数被称作是返回false或者说是false的时候，就是意味着他返回值是nil。然而，当一个函数被称作是返回true或者说是true的时候，就意味着返回除了nil以外的其他值，但是不一定是t。
######1.2.3 求值，展开和相等
Lisp代码的执行被称作是求值，因为一段代码的执行最后得出一个某数据对象的结果，被称作代码生成的值。符号->被用在显示求值的例子中。例：
``(+ 4 5)->9``
他的意思是代码(+ 4 5)求值的结果是（或者说将会是，已经是）9。
符号>>的意思是表示宏展开，例子：
``(push x v)>>(setf v (cons x v))``
上面的代码的意思是，宏调用(push x v)的展开结果是(setf v (cons x v))。这表示了两段代码做的事同样的事情，第二段代码就是第一段定义的。
符号==被用在表示代码相等：
(gcd x (gcd y z))==(gcd (gcd x y) z)
意思就是：无论x，y，z的输入值是什么，(gcd x (gcd y z))的值和效果，和(gcd (gcd x y) z)的值和效果是完全相同的。这表示两段代码做的事情是完全相同的；然而他们不是宏调用和宏展开的关系
######1.2.4 错误
当本书中出现“是一个错误”，在某些情况下出现这个信息的时候，意味着：
- 合法的Common Lisp程序不会引起错误。
- 如果错误出现，就是说在Common Lisp定义中，它的效果和结果是完全没有定义的。
- Common Lisp实现不会被要求去侦测这样的错误。当然，实现者被鼓励去提供合理范围的错误侦测。

不必说，一些特定的实现并没有定义错误出现的情况的相关结果和效果；重点在于，没有程序是遵照Common Lisp定义直接是依赖于这些效果或者结果。
另一方面，如果本书中定义的一些情况“一个错误出现的提示”，意味着：
- 如果错误出现，将会被提出提示（看error或者cerror）
- 合法的Common Lisp程序可能会依靠这个错误被提示的事实
- 每一个Common Lisp实现都被要求侦测这样一个错误

在一些地方会看到这些字眼，一定，一定不，和可能不，如果相应字眼的条件没有满足，就会出现错误。举例，如果说一个参数必须是一个符号，如果参数不是符号，就会报错。任何地方一个错误被提示，字眼“提示”总是在本书中会显式使用。
X3J13已经采用了一份更加详尽的错误术语，并作出努力来定义错误的类型，以便在合适的时候提示合适的错误类型。这些工作还没有完成，我尝试将新的错误术语或者本书中的错误类型定义进行具体化。新的术语描述和定义在第28章Common Lisp类型系统才出现；这给的是一个错误情况如何描述，如何做出正确的预定义，在正式的ANSI标准之前的尝鲜。
#####1.2.5 函数和其他实体的描述
函数，变量，具名常量，特殊形式还有宏都是用特别的印刷格式来描述。下面显示了Common Lisp的函数会怎样被描述。
``sample-function arg1 arg2 &optional arg3 arg4 [function]``
这个函数sample-function会把参数1和参数2加到一起，之后乘上参数3.如果参数3没有提供或者是nil的话，乘法就不完成。sample-function之后返回一个列表，第一个元素师结果，第二个元素师参数4（默认是符号foo）。
``(sample-function 3 4)->(7 foo)``
``(sample-function 1 2 2 'bar)->(6 bar)``
一般来说就是，(sample-function x y)>>(list (+ x y) 'foo)。
*sample-variable* [varibale]
变量*sample-variable*定义的是一个特殊形式sample-special-form应该迭代多少次。它的值应该是一个非负的整数或者nil（也就意味着迭代无限次）。初始值就是0（意思是没有迭代）。
sample-conatant[constant]
具名常量sample-constant的值在硬盘中存储是以2的对数的比特位数的波长乘数来定，和浮点数一样。
函数的第一行定义了函数的名字，接受的参数的形式，还有函数体本身。如果函数接受很多参数，参数列表的名字或许会绵延两到三行。之后的一段说明的就是一个函数头的ing一和使用一个函数的模板。
有时候几个相似的函数会精炼成一个简单的组合描述。
sample-special-form  [name]  ({var}) {form}+ [special form]
他会将每一个语句都作为隐式的progn来求值，迭代的次数就由sample-variable来决定。每一个变量var在第一次迭代之前都初始化为43，并且在最后一次迭代后销毁。名字name，如果有的话可能用在return-form语句上来从循环离开。如果循环正常的话，sample-special-form返回nil，例：
``(setq *sample-variable* 3)``
``(sample-special-form () form1 form2)``
求值顺序书语句1，语句2，语句1，语句2这样的顺序。
sample-marco var [[declaration |doc-string]] {tag | statement} [marco]
这些语句会作为一个prog函数体来求值，变量var是43.
``(sample-marco x (return (+ x x )))->86``
``(sample-marco var.body)>>(prog  ((var 43)).body)``
所有函数的头都会集中在一起，之后紧跟的就是组合描述。
一般来说，源代码（包含真实的函数名）是这样出现的：(cons a b)。那些代码片段缩写的名字（元变量）是用斜体写的。在函数描述中，为了说明需要，参数的名字都是斜体。参数列表中的&optional显示的是这些参数是可选的；参数的默认值在文本中描述。参数列表或许会包括&rest，表示后面的参数或许是无限的，还有&key表示关键词参数是可以使用的。（&optional/&rest/&key的语法在函数中的使用目的也是以上这些原因）。
方便起见，所有的Common Lisp全局变量的名字都是用星号包裹的。常量就像全局变量一样，但是有一点，改变常量的值会引发错误。特殊形式和宏，在目的上有着很大关联，但是和函数却很不同。函数使用简单一致的语法进行调用；&optional/&rest/&key的语法是说明函数内部的运作，但是不影响调用的语法。相比之下，每一个特殊形式或者宏可以有自己的独特的语法。通过特殊形式和宏，Common Lisp的语法就可以扩展和定义。

