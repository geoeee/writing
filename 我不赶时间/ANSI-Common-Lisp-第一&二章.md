###第一章 导语
约翰麦卡锡和他的学生在1956年开始着手第一个Lisp版本的实现工作。Lisp可以说是在Fortran之后现今还在使用的最古老的语言，更令人惊奇的是，Lisp仍然处在编程语言的前沿地位。熟知Lisp的程序员会告诉你，有一些东西使得Lisp与众不同。
Lisp特别的地方在于，他被设计成可进化的语言。你可以使用Lisp还ID能够一个新的Lisp操作符。一些新的抽象概念（比如面向对象），使用lisp来实现总是特别方便，他就像DNA，Lisp是一种不会过时的语言。
为什么学习Lisp？因为他可以做到其他编程语言做不到的事情，如果你只是想写一个简单的函数，比如把小于N的正整数加起来，使用C或者Lisp来实现是差不多的。
``; Lisp 
(defun sum (n) 
  (let ((s 0)) 
    (dotimes ( i n s) 
      (incf si))) ) ``
	  
``/* C */ 
int sum(int n){
  int i , s = 0; 
  for( i = 0; i < n; i++) 
    s += i ; 
  return(s) ; 
}``

如果只是做这样简单的事情，的确不需要在意使用什么语言。但要做另一些事情，比如写一个函数，接受输入n，他返回一个函数，把n加到它的参数列表中。
``; Lisp 
(defun addn (n) ``
  ``#'(lambda (x) 
      (+ x n))) ``
	  
用C来写addn是什么样子？你根本写不出来。
编程语言是不会教会你他根本无法实现的概念的，你在解决问题的时候必须使用一种语言的逻辑去思考，于是很难去想象一个根本用该语言难以描述的东西。当我一开始用basic编程的时候，根本不知道甚么是递归，我用basic来思考怎么解决。能想到的只有迭代算法，所以怎么会知道递归呢？
如果你没听过词法闭包（上面的范例就是），相信我，lisp程序员一直在使用它。很难找到一段common lisp程序是没有使用词法闭包的。
闭包也是唯一一个在其他语言中没有出现的抽象概念，另一个很有价值的特性就是，Lisp程序是用Lisp数据结构来表示的。这意味着你可以写一个程序来写程序。这个技术被称作宏。
有了宏，闭包和运行时类型，Lisp就超越了面向对象编程。如果你已经完全理解了这句话，也许这本书就没有必要读了。
###第二章 欢迎来到Lisp
本章的目的是让你尽快进入编程，到这一章结束你已经可以开始写Lisp程序了。
#####2.1 形式
实践是学习的捷径，每一个Lisp实现都自带一个解释器环境，只要在解释器的顶层输入代码，解释器就会计算出结果。
一般的解释器使用>做顶层提示符。
最简单的表达式就是整数。
``> 1 
1 ``
``>``
系统会打印一个值，然后回到提示符，准备接受下一个输入。
数字求值为自身，输入和打印结果是一样的。我们来试试将两个数字加到一起的表达式
``> (+ 2 3) 
5 ``
这个表达式里，+被称作操作符，数字2和3叫做参数。这种把操作符放在前面的形式叫做前缀表达式。我们平常的表达形式叫做中缀表达式，2+3。
前缀表达式的好处很大，比如在参数增加的时候，不需要增加操作符
``2+3+4
（+ 2 3 4）``
+操作符可以接受任何数量的参数，当然也包括没有参数。
``> (+) 
0 ``
``> (+ 2) 
2 ``
``> (+ 2 3) 
5 ``
``> (+ 2 3 4) 
9 ``
``> (+ 2 3 4 5) 
14 ``
表达式的嵌套可以构造很复杂的表达式。
``> ( / (- 7 1) (- 4 2) ) 
3 ``
这种表达式的另一个好处就是极尽简单，一对括号，里面是数字或者元字符或者列表，这就是全部。所有的Lisp程序也都是这样。C语言的语法就复杂很多，而在Lisp中，我们用简单的形式表达一切概念。
#####2.2 求值
本节我们看看表达式是如何求值的。
Lisp中，+是一个函数，表达式（+ 2 3）是一个函数调用。求值一个函数调用，会有两个步骤：
1.首先参数从左到右求值。
2.参数的值传入函数。
如果任何参数本身就是函数调用，就会按照一样的规则求值。
并不是所有的操作符都是函数，但大部分是的。任何函数都是按照这样两个步骤求值的，先计算参数，然后传给函数，这叫做Common Lisp的求值规则。
中断循环是在输入有错误，Lisp本身无法理解的时候会进入的状态，对于有经验的程序员，这个状态可以找到出错的地方，现在我们只要学会如何跳出去。
``> (/ 1 0) 
Error: Division by zero. 
Options: :abort, :backtrace ``
``>>:abort ``
``> ``
有一个操作符是不遵守求值规则的，quote。他是一个特殊操作符，他会把参数原样返回。
``> (quote (+ 3 5) ) 
(+ 3 5) ``
方便起见，Common Lisp使用单引号'作为quote的缩写。效果当然是一样的。
``> '(+ 3 5) 
(+ 3 5) ``
这个单引号的使用比quote要频繁的多，单引号操作符的作用是保护参数不被求值，后面会解释为什么单引号很有用。
#####2.3 数据
别的语言里提供的数据类型，Lisp里都有，没有的我们也有。我们用过的一个叫做整型数，写出来是一系列数字：256。另一个在Lisp里使用广泛的是字符串，用双引号括起来的一些列字符"ora e t labora"。整型数和字符串都是求值为自身的。
在其他语言里没有的两个类型是符号和列表，符号就是单词，一般会转化成大写。
``> 'Artichoke 
ARTICHOKE `` 
符号一般不求值为自身，所以如果你确实是用一个符号的话，加上单引号吧。
列表是括号里面的一系列元素。元素可以使任何类型，也包括了列表。要是用作参数，那肯定要加上单引号。
``> '(my 3 "Sons") 
(MY 3 "Sons") ``
``> '(the list (a b c) has 3 elements) 
(THE LIST (A B C) HAS 3 ELEMENTS) ``
请注意一个单引号会保护一整个表达式，也包括里面嵌套的表达式。
调用list可以创建列表，list函数的参数是求值的。
``> (lis t 'my (+ 2 1) "Sons") 
(MY 3 "Sons") ``
刚看到的就是好lisp最为人好评的一个性质，用列表来表示程序。这意味着可以使用程序来写程序也是可能的。具体方法后面再说，以免被误导。如果一个参数中有的加上了单引号，有的没有，他们会被区别对待。
``> (lis t '(+ 2 1) (+ 2 1)) 
((+ 2 1) 3) ``
第一个参数没有被求值，第二个被求值了。
对于空的列表，有两种表达方式，一个是一对括号，里面什么都没有，还有就是符号nil。
``> 0 ``
``NIL ``
``> nil ``
``NIL ``
nil是求值为自身的，所以加不加引号没有什么关系。
#####2.4 列表操作
cons函数构建列表。第二个参数是列表的话就会构建一个新的，在前面加上一个元素。
``> (cons ' a ' (b c d) ) 
(A B C D) ``
cons可以从一个空列表开始建立列表，list的做法更加方便一些。
``> (cons 'a (cons 'b nil) ) 
(A B) ``
``> (list 'a 'b) 
(A B) ``
从列表中提取元素的是原始函数car和cdr。car会提取第一个元素。cdr会提取第一个元素之后的元素。
``> (car '( a b c) ) 
A ``
``> (cdr '( a b c) ) 
(B C) ``
使用car和cdr的组合就可以提取想要的元素，假如是第三个。
``> (car (cdr (cdr '( a b c d))) ) 
C ``
更加简便的就是直接调用third
``> (third '( a b c d) ) 
C ``
#####2.5 真值
在Common Lisp中，符号t是默认的真值，他是求值为自身的，就像nil一样，函数listp判断参数是不是一个列表，是就返回T。
``> (listp '( a b c) ) 
T ``
返回的结果是T或者nil这样的真假值的函数就叫做判断式。Common Lisp的判断式经常以p结尾。假值使用nil或者空列表来表示，如果给listp的输入不是列表，返回nil。
``> (list p 27) 
NIL ``
函数null，输入是空列表的话就会返回T。
``> (nul l nil ) 
T ``
函数not，参数是假的话就会返回T。
``> (not nil ) 
T ``
实际上nil有了两个角色，功能是一样的。
最简单的条件式就是if。一般接受三个参数：一个测试表达式，真值部分表达式和假值部分表达式。对测试部分求值，返回T就对真值部分求值返回，nil就对假值部分求值返回。
``>(if (listp '( a b c)) 
(+ 1 2) 
(+ 5 6)) 
3 ``
``> (if (listp 27) 
(+ 1 2) 
(+ 5 6)) 
11``
跟quote一样，这是个特殊操作符，他不能像普通函数一样使用，因为普通的函数总是对参数求值的，if只对部分参数求值。
``>(if (listp 27) (+ 2 3)) 
NIL ``
虽然T是一个真值的默认表达式，但是除了nil之外的所有东西都被当做真值对待。
``>(if 27 1 2) 
1 ``
裸机操作符and和or类似于判断式。都会接受任意数量的参数，但是会有求值短路现象，就是说，and，遇到一个nil就不再对后面的参数求值，or，遇到一个非nil，就不会再对后面的参数求值。
``>(and t (+ 1 2) ) 
3 ``
这两个操作符都是宏，跟特殊操作符一样，宏是可以避开求值规则的。
#####2.6 函数
defun函数，用来定义新的函数。一般接受三个或者更多参数：一个函数名，参数列表和函数体。下面是Third的定义：
``> (defun our-thir d (x) 
(car (cdr (cdr x))) ) 
OUR-THIRD ``
第二个参数位置上的符号X，被称作变量名，也叫做参数，表示函数的输入参数。第三部分是函数体，决定了计算的具体操作过程。
``> (our-third '(a b c d)) 
C ``
一个符号有时候必须被引用的原因就是因为，如果没有引用的话，符号就会被看做是变量名。通过替换特殊位置的参数，就可以将一个表达式变成函数定义，下面的函数就是判断两个数的和是不是大于第三个数。
``> (> (+ 1 4) 3) 
T ``
``> (defun sum-greater (x y z) 
(> (+ x y) z)) 
SUM-GREATER 
``> (sum-greater 1 4 3) 
T ``
在lisp中，没有程序，过程和函数概念上的区别。函数包办一切。当然也可以定义一个main函数之类的，但是已经有顶层调用，可以将程序一步步调用。
#####2.7 递归
之前的函数都是调用别的函数来计算，函数也可以调用自身。这个行为的术语叫做递归。函数member判断一个元素是不是在一个列表中：
``(defun our-member (obj 1st) 
    (if (null 1st) 
      nil 
      (if (eql (car 1st) obj) 
        1st 
        (our-member obj (cdr 1st))))) ``
判断式eql测试两个参数是不是完全相同的函数。
``> (our-member 'b '(a b c)) 
(B C) ``
``> (our-member 'z '(a b c)) 
NIL ``
解释一下如何判断一个元素obj是不是术语一个列表lst。
检查列表是不是为空，是，结束，否则进入判断元素是不是列表的第一个元素，是，返回，不是，调用自身，用后面的元素作为输入接着判断。
对于递归的误解可能来自于错误的比喻，程序本身并不是一个流水线机器，而是一个过程，机器不能自己使用自己，但是过程可以在任何一点重新启动一个过程，然后再返回那个点。
#####2.8 阅读列表
在写lisp程序的时候，大量的括号会把人逼疯，但是只要有一个支持括号配对高亮的编辑器，加上合适的缩进风格，程序看上去就好多了。
``(defun our-member (obj 1st) (if (null 1st) nil (if (eql (car 1st) obj) 1st (our-member obj (cdr 1st))))) ``
``defun our-member (obj 1st) 
    if null 1st 
      nil 
      if eql (car 1st) obj 
        1st 
        our-member obj (cdr 1st) ``
#####2.9 输入和输出
通过解释器，我们已经隐式使用过输入和输出了，我们来看一些输入和输出的函数。format函数是使用最广泛的，接受两个或者更多输入参数，第一个是决定打印的地方，第二个是格式化字符串，后面的是代替控制字符插入字符串的参数。
``> (format t "~A plus ~A equals ~A.T' 2 3 (+2 3)) 
2 plus 3 equals 5. 
NIL ``
这里的两行输出粉别是format打印的输出和format的返回值。一般format是不会被顶层调用的，他会用在程序里面，那时候返回值就不可见了。
第一个参数t的意思是打印到默认的地方。也就是顶层。第二个参数是一个输出字符串，控制字符~A是一个待插入的位置，~%表示换行，这些控制字符会被后面的参数一个个代替。
标准的输入函数是read，没有输入参数的时候，就会默认输入等待，直到有输入出现。
``(defun askem (string) 
(format t ""A" string ) 
(read) ) ``
``> (askem "How old are you? ") 
How old are you? 29 
29 ``
在调用read之前，一般会打印一些提示输入的信息，不然会以为程序当掉了。read的强大之处在于他是一个完整的解析器，可以将输入转化成相应的lisp对象，上面的例子就是把输入转化成了数字。
函数的函数体是可以包含多条表达式的，至于返回值是最后一条表达式的值。
在之前的章节中，我们使用的算是纯洁的lisp，也就是没有副作用的lisp。但是有时候求值一个表达式会有副作用，比如format函数，打印的信息就是他的副作用。
在函数体中的多条表达式，只有最后一条的值会返回，之前的表达式如果没有副作用的话就会变得毫无用处。
#####2.10 变量
最常使用的操作符就是let，他会让你引入一些新的局部变量。
``> (let ((x 1) (y 2)) 
(+ x y))``
一个let表达式有两个部分，第一个是创建变量的一系列指令，每一个的形式都是（变量名 表达式），每一个变量都会被初始化成相应的表达式的值。上面的例子中，我们先初始化了x和y，之后开始计算。
上面这些变量叫做局部变量，只在自己的环境内是合法的，全局变量的定义需要使用函数defparameter：
``> (defparameter *glob* 99) 
•GLOB* ``
全局变量哪里都可以访问，除非是在一个具有同样名字局部变量的环境里。为了防止名字冲突发生，一般会给全局变量的两边加上星号来表示。
全局常量是用defconstant来表示。
``(defconstant limit (+ *glob* 1)) ``
其实没有必要给常量特殊的命名方式，因为如果把常量当变量使用，就会报错。检查一个名字是不是全局变量或者常量的方法是用函数boundp：
``> (boundp '*glob*) 
T ``
#####2.11 赋值
最常用的赋值操作符是setf，我们可以用任意一种变量来赋值。
``> (set f *glob* 98) 
98 ``
``> (let ((n 10)) 
      (set f n 2) 
         n) 
2 ``
可以使用setf来隐式创建全局变量，但是更好还是用defparameter来显式创建全局变量。
setf的第一个参数不是一定是一个变量名，也可以是一个位置的描述。
``> (set f (car x) 'n) 
N ``
``> x 
(N B C) ``
#####2.12 函数式编程
函数式编程的意思是通过函数的返回值而不是修改一些对象来进行工作，这是Lisp的范式。大部分内建函数是因为他们的返回值而被调用，而不是因为副作用。
函数remove，接受一个对象和一个列表作为输入，然后返回一个不包含该对象的列表。
``> (set f 1st '(c a r a t) ) 
(CARAT ) ``
``> (remove 'a 1st ) ``
(C R T) ``
为什么不说remove删除了对应元素呢？因为真正发生的事情不是这样。
``> 1st 
(CARAT ) ``
如果你真的想要删除这个列表中的元素，应该把remove的返回值再赋值给X，那样就真的改变了列表。
``(setf x (remove 'a x)) ``
函数是编程的意思是基本上避免使用setf和修改对象，一开始你可能会觉得不可思议，怎么可能仅仅通过返回值来编程。
完全不使用副作用的话也是很不方便，读下去，你会发现，其实也还好。更少副作用的时候，你更加厉害。
函数式编程最大的一个好处就是他允许交互式测试，在完全的函数式代码中，你可以通过看到返回值正常与否来判断程序是否正常，这是一种全新的编程风格。
#####2.13 迭代
想要重复地做一件事的时候，非常自然的就想到了迭代。一个典型的情景就是生成表格的时候。
``(defun show-squares (start end) 
    (do (( i start (+ i 1)) ) 
      ((> i end) 'done) 
    (format t "~A ~k~l" i (* i i)))) ``
``> (show-squares 2 5) 
2 4 
3 9 
4 16 
5 25 
DONE ``
宏do是common lisp中的迭代操作符。就像let，do可以创建变量，第一个参数是定义变量的列表。每一个元素都是以这样的形式（变量 初始化 更新）
``{variable initial update) ``
变量是一个符号，初始化和更新都是表达式，初始化就是对创建的变量赋值，更新就是每一次迭代会执行的表达式。
第二个参数是是一个包含一个或者多个的列白哦。第一个表达式被用在测试迭代是不是可以结束了。剩下的表达式是会依次求值。最后一个表达式的值会作为do的值，
剩下的参数构成了循环体，会在每一次迭代中求值，每一次迭代，变量都会更新。
``(defun show-squares (i end) 
(if (> i end) 'done 
(progn 
  (format t M~A ~A~°/,n i (* i i) ) 
  (show-squares (+ i 1) end))) ) ``
progn函数会对每一个表达式依次求值，然后返回最后一个的值。
Common Lisp有为特殊情况准备简单的迭代操作符。dolist用在迭代列表的元素上。最后他会返回列表的长度。
``(defun our-length (1st) 
(let ((len 0)) 
(dolist (obj 1st) 
(setf len (+ len 1))) 
len)) ``
dolist的参数形式是（变量 表达式），然后遍历列表的每一个元素。
对应的递归版本：
``(defun our-length (1st) 
(if (null 1st) 
0 
(+ (our-length (cdr 1st)) 1))) ``
如果列表为空的话，长度就是0。如果不为空，长度就是cdr加上1。
#####2.14 函数作对象
Lisp中，函数是一般的对象，就像符号和字符串，还有列表。如果把函数名输入function函数，就会返回相应的信息，跟quote一样，function是一个特殊函数，它的参数不需要引用
``> (function +) ``
``#<Compiled-Function + 17BA4E> ``
在计算机内部，函数+的代码可能是一段汇编语言的代码，至于打印成甚么样，每一个Lisp实现都不一样。
quote函数的缩写是单引号'，function函数的缩写是#'。
``> #' + ``
``>#<Compiled-Function + 17BA4E> ``
就像其他的对象一样，我们可以吧函数当做参数适用。apply函数接受函数作为参数。返回就是函数的求值结果。
``> (apply #'+ '( 1 2 3)) 
6 ``
``> (+ 1 2 3) ``
``6 ``
任意数量的参数都ok，只要最后的一个是列表就好。
函数funcall和apply做的差不多，只是不需要参数被包裹成列表。
``> (funcal l #»+ 1 2 3) 
6 ``
宏函数defun创造具名函数，但是函数不一定要有名字，我们也不一定需要defun来定义。我们使用lambda表达式来指向一个函数，lambda表达式就是lambda后面跟着很多参数。
``(lambda (x y) (+ x y)) ``
列表（x y）就是参数列表，之后的就是函数体，
``> ((lambda (x) (+ x 100)) 1) 
101 ``
加上井号引号时候，我们就得到了对应的函数
``> (funcall #'(lambda (x) ( + x 100)) 1) 
101 ``
#####2.15 类型
在很多语言中，变量都有自己的类型，而且你不可以使用没有定义类型的变量。在Common Lisp中，变量是没有类型的，但是值是有的。你可以想象一下在每一个对象上都有一个标签，写明了类型。这叫做显式类型。不一定要声明变量的类型，因为变量可以保有任何类型的对象。
内建的类型形成了一个子类和超类的体系。一个对象总是有超过一个类型。比如数字27就是定点数，整数，实数，原子，类型t是所有类型的超类，所有的对象都是t类型。
函数typep接受一个对象和一个类型定义，返货对象是不是属于哪个类型。
``> (typep 27 'integer)
T``
#####2.16 展望
在本章我们已经了解了一些Lisp的皮毛。一个语言的肖像见见浮现出来。一开始，语言有了一个表达所有编程结构的单一语法，语法是基于列表的，也是一种Lisp对象。函数，也可以用列表的形式表现。还有，Lisp语言本身就是用Lisp定义的。
不要担心这些概念之间的关系是不是很清晰，Lisp引入了很多新奇的概念来然你熟悉他们，这中间有很多惊人优雅的概念。一个语言可以做一个很好用的特别应用和语言定义语言自身是非常不一样的。他打开了一条编程的新思路，可以用程序自己发展语言本身。
#####概述
1. Lisp是一个解释型语言，在顶层键入表达式，Lisp会返回值。
2. Lisp程序由表达式组成。一个表达式可以是一个原子，或者是由操作符和参数组成的列表。
3. 函数调用的求值规则：对参数从左到右求值，之后传传给函数。quote操作符有自己的求值规则，就是不加改变的返回参数。
4. 除了一般的数据类型之外，Lisp还有符号和列表。因为Lisp程序是由列表来表达的，就很方便的创建编程序的程序。
5. 三个基本的列表函数是cons，会建立一个列表；car会返回列表的第一个元素；cdr会返回除了第一个元素之外的列表。
6. 在Common Lisp中，t表示true，nil表示false。在一个逻辑环境下，任何不是nil的东西都被看做true。基本的条件式是if。and和or操作符类似于条件式。
7. Lisp主要是由函数组成，你可以使用defun来定义一个新的函数。
8. 函数调用自身叫做递归。一个递归函数应该被看做一个过程而不是一部机器。
9. 括号之所以不会成为问题是因为程序员使用缩进来标明程序。
10. 基本的I/O函数是read，他包含完整的Lisp解析器，还有format，是基于一个模板来进行输出。
11. let用来创造新的局部变量，全局变量的创建使用defparameter。
12. 赋值操作符是setf，他的第一个参数可以是表达式。
13. 函数式编程的意思是避免副作用的存在，是Lisp中占支配性的编程范式。
14. 基本的迭代操作符是do。
15. 函数是常规的Lisp对象。他们可以被当做参数传递，也指代了lambda表达式。
16. 在Lisp中值有类型，变量没有类型。

